;; -*- mode: scheme; -*-
;; Egglab Copyright (C) 2013 Dave Griffiths
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU Affero General Public License as
;; published by the Free Software Foundation, either version 3 of the
;; License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU Affero General Public License for more details.
;;
;; You should have received a copy of the GNU Affero General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (new-butterfly-state pos dir)
  (list pos dir (rndf) (random 32)))

(define (butterfly-state-pos s) (list-ref s 0))
(define (butterfly-state-modify-pos s v) (list-replace s 0 v))
(define (butterfly-state-dir s) (list-ref s 1))
(define (butterfly-state-modify-dir s v) (list-replace s 1 v))
(define (butterfly-state-fuzz s) (list-ref s 2))
(define (butterfly-state-texture s) (list-ref s 3))

(define (butterfly-screen-pos s)
  (project-point (butterfly-state-pos s)))

(define (update-butterfly-state s)
  (let ((a 0.03))
  (let ((dir (butterfly-state-dir s)))
    (butterfly-state-modify-pos
     (butterfly-state-modify-dir
      s
      (vector (+ (* (vx dir) (cos a)) (* (vy dir) (- 0 (sin a))))
              (+ (* (vx dir) (sin a)) (* (vy dir) (cos a)))
              0))
     (vadd (butterfly-state-pos s)
           (vmul dir 0.05))))))

(define (update-butterflies b)
  (map
   (lambda (b)
     (update-butterfly-state b))
   b))

(define (render-butterfly s)
  (with-state
   (texture (list-ref test-tex (butterfly-state-texture s)))
   (translate (butterfly-state-pos s))
   (maim (vnormalise (butterfly-state-dir s)) (vector 0 0 1))
   (rotate (vector 0 90 90))
   (scale (vector 0.5 0.5 0.5))
   (draw-obj 4)
   (with-state
    (rotate (vector 180 0 0))
    (translate (vector 0 0 -0.5))
    (let ((a (* 90 (sin (* 10 (+ (butterfly-state-fuzz s) (time)))))))
      (with-state
       (rotate (vector 0 0 a))
       (draw-obj 3))
      (with-state
       (rotate (vector 0 0 (- 0 a)))
       (draw-obj 3))))))

(define (render-butterflies s)
  (for-each
   (lambda (p)
     (render-butterfly p))
   s))

(define (new-butterfly)
  (new-butterfly-state (vmul (crndvec) 15) (vnormalise (crndvec))))

(define butterfly-state
  (build-list
   20
   (lambda (i) (new-butterfly))))

(define test-tex (build-list 32 (lambda (i) (load-texture (+ "patterns/" (+ i 1) ".png")))))
(define bg-tex (load-texture "bg.png"))

(define (render)
  (set! butterfly-state (update-butterflies butterfly-state))
  (render-butterflies butterfly-state)
  (with-state
   (texture bg-tex)
   (translate (vector 0 0 -100))
   (scale (vector 100 100 100))
   (draw-cube)))

(shader blinn-vertex-shader
"
precision mediump float;
varying vec3 N;
varying vec3 P;
varying vec3 V;
varying vec3 L;
varying vec3 T;
uniform sampler2D texture;
void main() {
 gl_FragColor = texture2D(texture,vec2(T.s,T.t));
}
")


(define (stroke-pie ctx x y time max-time)
  (ctx.beginPath)
  (ctx.moveTo x y)
  (ctx.arc
   x y 50 (+ (* Math.PI -0.5)
             (/ (* time Math.PI 2) max-time))
   (* Math.PI -0.5)
   true)
  (ctx.closePath))

(define (draw-pie ctx x y time max-time r g b)
  (stroke-pie ctx (+ x 3) (+ y 3) max-time max-time)
  (set! ctx.fillStyle "#000")
  (ctx.fill)

  (stroke-pie ctx x y time max-time)
  (set! ctx.fillStyle (string-append "rgba(" (Math.floor r) ", "
                                     (Math.floor g) ", "
                                     (Math.floor b) ", 1.0)"))
  (ctx.fill)

  (set! ctx.lineWidth 1)
  (set! ctx.fillStyle "#fff")
  (set! ctx.font "normal 30pt gnuolane")
  (ctx.fillText (Math.floor time) x (+ y 20))
  )

(define (draw-flash ctx x y rad r g b a)
  (ctx.beginPath)
  (ctx.arc x y rad 0 (* Math.PI 2) true)
  (ctx.closePath)
  (let ((grd (ctx.createRadialGradient x y 50 x y 100)))
    (grd.addColorStop 0 (string-append "rgba(0, 255, 0, " a ")"))
    (grd.addColorStop 1 (string-append "rgba(255, 255, 0, 0.0)"))
    (set! ctx.fillStyle grd)
    (ctx.fill)))

(define (make-gobble x y)
  (set! gobble-x x)
  (set! gobble-y y)
  (set! gobble-t 0))

(define gobble-x 0)
(define gobble-y 0)
(define gobble-t 1)

(define (draw-gobble ctx)
  (when (< gobble-t 1)
        (ctx.beginPath)
        (ctx.arc gobble-x gobble-y
                 (* (- 1 gobble-t) 100)
                 0 (* Math.PI 2) true)
        (ctx.closePath)
        (let ((grd (ctx.createRadialGradient
                    gobble-x gobble-y (* (- 1 gobble-t) 10)
                    gobble-x gobble-y (* (- 1 gobble-t) 100))))
          (grd.addColorStop 0 (string-append "rgba(0, 155, 0, " a ")"))
          (grd.addColorStop 1 (string-append "rgba(255, 255, 0, 0.0)"))
          (set! ctx.fillStyle grd)
          (ctx.fill))
        (set! gobble-t (+ gobble-t 0.2))))


(define (clamp v min max)
  (cond
   ((< v min) min)
   ((> v max) max)
   (else v)))

(define flash 0)
(define energy 50)

(define (nightjar-intro c)
  (game-modify-mouse-hook
   (lambda (e c)
     (define found 0)
     (set! butterfly-state
           (filter
            (lambda (b)
              (let ((pos (butterfly-screen-pos b)))
                (cond ((and (zero? found)
                            (< (vdist (vector (game-mx c) (game-my c) 0) pos) 50))
                       (make-gobble (vx pos) (vy pos))
                       (set! energy (+ energy 5))
                       (set! flash 255)
                       (set! found 1)
                       #f) (else #t))))
            butterfly-state))
     c)
   (game-modify-render
    (lambda (ctx)
      (set! flash (* flash 0.9))

      (set! energy (clamp (- energy (* 10 (game-time-delta c))) 0 100))

      (draw-pie ctx 70 700 10 100 255 0 0)
      (draw-pie ctx 1100 700 energy 100
                0 220 120)

      (when (> flash 10)
            (draw-flash ctx 1100 700
                        200
                        127 255 200 (/ flash 255)))

      (set! ctx.strokeStyle "#fff")


      ;;(for-each
      ;; (lambda (b)
      ;;   (let ((pos (butterfly-screen-pos b)))
      ;;     (ctx.beginPath)
      ;;     (ctx.arc (vx pos) (vy pos) 50 0 (* Math.PI 2) true)
      ;;     (ctx.closePath)
      ;;     (ctx.stroke)))
      ;; butterfly-state)

      (set! ctx.fillStyle "#fff")
      (set! ctx.font "normal 10pt gnuolane")

      (wrap-text ctx
                 (string-append "Num butterflies: " (length butterfly-state))
                 -470 100 1000 1000)

      (draw-gobble ctx)
      )
    (game-modify-buttons
     (list
      (image-button
       "" 80 100 "none" (find-image "plus.png")
       (lambda (c)
         (set! butterfly-state (cons (new-butterfly) butterfly-state))
         c))

      (image-button
       "" 50 100 "none" (find-image "minus.png")
       (lambda (c)
         (set! butterfly-state (cdr butterfly-state))
         c))


      )
     c))))




(every-frame (render))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; startup

(load-images!
 (append
  (list
   "heliconius.png"
   "plus.png"
   "minus.png"))
 (lambda ()
   (start-game canvas ctx)))
